<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="五大常用算法">
<meta property="og:type" content="article">
<meta property="og:title" content="五大常用算法">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;05&#x2F;26&#x2F;%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95&#x2F;index.html">
<meta property="og:site_name" content="翻个片马">
<meta property="og:description" content="五大常用算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;05&#x2F;26&#x2F;%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95&#x2F;tree.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;05&#x2F;26&#x2F;%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95&#x2F;map.png">
<meta property="article:published_time" content="2020-05-26T07:52:23.000Z">
<meta property="article:modified_time" content="2020-06-13T09:35:47.126Z">
<meta property="article:author" content="swaggyTech">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;05&#x2F;26&#x2F;%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95&#x2F;tree.png">

<link rel="canonical" href="http://yoursite.com/2020/05/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>五大常用算法 | 翻个片马</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">翻个片马</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="swaggyTech">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="翻个片马">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          五大常用算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-26 15:52:23" itemprop="dateCreated datePublished" datetime="2020-05-26T15:52:23+08:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-13 17:35:47" itemprop="dateModified" datetime="2020-06-13T17:35:47+08:00">2020-06-13</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
              <span class="post-meta-divider">|</span>
              <span title="post.wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span>字数： 3.7k</span>

            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/05/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/05/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <center>五大常用算法</center>

<a id="more"></a>

<!--toc-->

<h2><span id="fen-zhi-suan-fa">分治算法</span><a href="#fen-zhi-suan-fa" class="header-anchor">#</a></h2><h3><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h3><p>把一个复杂的问题分成若干个相同或相似的子问题，再把子问题分成更小的子问题… ， 知道最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<h3><span id="gua-yong-chang-jing">适用场景</span><a href="#gua-yong-chang-jing" class="header-anchor">#</a></h3><p>1）当问题规模缩小到一定的程度就可以很容易解决<br>2）该问题可以分解为若干个规模较小的相同问题<br>3）该问题分解出的若干子问题的解可以合并为该问题的解<br>4）每个子问题都是独立的，相互之间没有交集。</p>
<h3><span id="jing-dian-chang-jing">经典场景</span><a href="#jing-dian-chang-jing" class="header-anchor">#</a></h3><p>1）二分搜索<br>2）大整数乘法<br>3）合并排序<br>4）快速排序<br>5）汉诺塔</p>
<h3><span id="jing-dian-li-ti">经典例题</span><a href="#jing-dian-li-ti" class="header-anchor">#</a></h3><p>一组整数，求出这组数字子序列和中的最大值。即求出最大子序列的和，不必求出最大的那个序列，例如，-2,11，-1,13，-5，-2，则最大子序列的和为20。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a = &#123; -<span class="number">2</span>, <span class="number">11</span>, -<span class="number">4</span>, <span class="number">13</span>, -<span class="number">5</span>, -<span class="number">2</span> &#125;;<span class="comment">// 最大子序列和为20</span></span><br><span class="line">	<span class="keyword">int</span>[] b = &#123; -<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">9</span>, <span class="number">10</span>, -<span class="number">2</span> &#125;;<span class="comment">// 最大子序列和为16</span></span><br><span class="line">	System.out.println(maxSubSum1(a));</span><br><span class="line">	System.out.println(maxSubSum4(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大子序列求和算法一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum1</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从第i个开始找最大子序列和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 找第i到j的最大子序列和</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 计算从第i个开始，到第j个的和thisSum</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">				thisSum += a[k];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果第i到第j个的和小于thisSum，则将thisSum赋值给maxSum</span></span><br><span class="line">			<span class="keyword">if</span> (thisSum &gt; maxSum) &#123;</span><br><span class="line">				maxSum = thisSum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(n的平方)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 将sumMax放在for循环外面，避免j的变化引起i到j的和sumMax要用for循环重新计算</span></span><br><span class="line">		<span class="keyword">int</span> sumMax = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">			sumMax += a[j];</span><br><span class="line">			<span class="keyword">if</span> (sumMax &gt; maxSum) &#123;</span><br><span class="line">				maxSum = sumMax;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归，分治策略</span></span><br><span class="line"><span class="comment">// 2分logn，for循环n，时间复杂度O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum3</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> maxSumRec(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSumRec</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 递归中的基本情况</span></span><br><span class="line">	<span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[left] &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> a[left];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 最大子序列在左侧</span></span><br><span class="line">	<span class="keyword">int</span> maxLeftSum = maxSumRec(a, left, center);</span><br><span class="line">	<span class="comment">// 最大子序列在右侧</span></span><br><span class="line">	<span class="keyword">int</span> maxRightSum = maxSumRec(a, center + <span class="number">1</span>, right);</span><br><span class="line">	<span class="comment">// 最大子序列在中间（左边靠近中间的最大子序列+右边靠近中间的最大子序列）</span></span><br><span class="line">	<span class="keyword">int</span> maxLeftBorderSum = <span class="number">0</span>, leftBorderSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = center; i &gt;= left; i--) &#123;</span><br><span class="line">		leftBorderSum += a[i];</span><br><span class="line">		<span class="keyword">if</span> (leftBorderSum &gt; maxLeftBorderSum)</span><br><span class="line">			maxLeftBorderSum = leftBorderSum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxRightBorderSum = <span class="number">0</span>, rightBorderSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = center + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">		rightBorderSum += a[i];</span><br><span class="line">		<span class="keyword">if</span> (rightBorderSum &gt; maxRightBorderSum)</span><br><span class="line">			maxRightBorderSum = rightBorderSum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回最大子序列在左侧，在右侧，在中间求出的值中的最大的</span></span><br><span class="line">	<span class="keyword">return</span> max3(maxLeftSum, maxRightSum, maxLeftBorderSum + maxRightBorderSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度:O(n); 任何a[i]为负时，均不可能作为最大子序列前缀；任何负的子序列不可能是最有子序列的前缀</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum4</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxSum = <span class="number">0</span>, thisSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">		thisSum += a[j];</span><br><span class="line">		<span class="keyword">if</span> (thisSum &gt; maxSum)</span><br><span class="line">			maxSum = thisSum;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (thisSum &lt; <span class="number">0</span>)</span><br><span class="line">			thisSum = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="dong-tai-gui-hua-suan-fa">动态规划算法</span><a href="#dong-tai-gui-hua-suan-fa" class="header-anchor">#</a></h2><h3><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h3><p>将待求解的问题分解为若干个子问题，按顺序求解子问题，前一问题的解，为后一问题的求解提供有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各种子问题，最后一个子问题就是初始问题的解。<br>由于动态规划算法解决的问题是有重叠的子问题，为了减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。<br>动态规划算法以分治算法类似，不同在于：适合于动态规划算法求解的问题，经分解后得到的子问题，往往不是互相独立的，而是下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步求解的。</p>
<h3><span id="gua-yong-chang-jing">适用场景</span><a href="#gua-yong-chang-jing" class="header-anchor">#</a></h3><p>1）最优化原理：该问题的最优解所包含的子问题的解也是最优的。<br>2）无后效性：某阶段状态一旦确定，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，只与当前状态有关。<br>3）有重叠子问题：即子问题之间不相互独立，一个子问题的解在下一阶段决策中可能被多次使用到。</p>
<h3><span id="jing-dian-wen-ti">经典问题</span><a href="#jing-dian-wen-ti" class="header-anchor">#</a></h3><p>给定两个字符串str1和str2，返回两个字符串的最长公共子序列，例如：str1=“1A2C3D4B56”,str2=“B1D23CA45B6A”,”123456”和”12C4B6”都是最长公共子序列</p>
<p>经典的动态规划问题，假设str1的长度为M, str2的长度为N, 则生成M*N的二维数组dp, dp[i][j]的含义是str1[0…i]与str2[0…j]的最长公共子序列的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String A = <span class="string">"1A2C3D4B56"</span>;</span><br><span class="line">	String B = <span class="string">"B1D23CA45B6A"</span>;</span><br><span class="line">	System.out.println(findLCS(A, A.length(), B, B.length()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(String A, <span class="keyword">int</span> Alen, String B, <span class="keyword">int</span> Blen)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[Alen+<span class="number">1</span>][Blen+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Alen; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Blen; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A.charAt(i) == B.charAt(j)) &#123;</span><br><span class="line">				dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[Alen][Blen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="tan-xin-suan-fa">贪心算法</span><a href="#tan-xin-suan-fa" class="header-anchor">#</a></h2><h3><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h3><p>通过局部最优解达到全局最优解</p>
<h3><span id="yu-dp-dui-bi">与DP对比</span><a href="#yu-dp-dui-bi" class="header-anchor">#</a></h3><p>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜<strong>不是</strong>最优解。</p>
<p>​    [背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。</p>
<p>​    要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>
<p>​    物品 A B C D E F G</p>
<p>​    重量 35 30 60 50 40 10 25</p>
<p>​    价值 10 40 30 50 35 40 30</p>
<p>​    分析：<br>​        目标函数： ∑pi最大</p>
<p>​    约束条件是装入的物品总重量不超过背包容量，即∑wi&lt;=M( M=150)<br>​        1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优呢？<br>​        2）每次挑选重量最小的物品装入背包，是否能得到最优解？<br>​        3）每次选取单位重量价值最大的物品，成为解本地的策略？</p>
<p>贪心算法简单易行，但贪心算法需要证明后才能真正运用到算法中。一般来说，<strong>贪心算法的证明围绕着整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</strong></p>
<p>对于本题的三种贪心策略，都无法成立，即无法被证明。解释如下：</p>
<p>​    1）选取价值最大者。<br>​        反例：W=30<br>​        物品：A B C<br>​        重量：28 12 12<br>​        价值：30 20 20</p>
<p>​    根据策略，选A, 但选BC最合适</p>
<p>​    2）选取重量最小，反例与上述类似</p>
<p>​    3）选取单位重量价值最大的物品。反例：<br>​        W=30<br>​        物品：A B C<br>​        重量：28 20 10<br>​        价值：28 20 10</p>
<p>​    根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</p>
<h3><span id="jing-dian-wen-ti">经典问题</span><a href="#jing-dian-wen-ti" class="header-anchor">#</a></h3><p>设有n个正整数，将他们连成一排，组成一个最大的多位整数。<br>例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。<br>又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。</p>
<p>要求输入：n, N个数<br>输出：连成的多位数</p>
<p>算法分析：该题很容易想到贪心法，但解题时很多人把整数按从大到小的顺序连接起来，测试题目的例子也都符合，但结果不对。例如：我们很容易找到12, 121应该组成12121而非12112， 但如12, 123呢，就是12312，而不是12123。所以，通过整数排序的方法是不对的。</p>
<p>结论：该题可以用贪心算法，只是刚才采用的贪心策略不对。正确的贪心算法的标准是：先把整数转成字符串，然后再比较a+b和b+a, 如果a+b &gt;= b+a, 就把a排在b前面, 反之把a排在b后面。</p>
<h2><span id="hui-su-suan-fa">回溯算法</span><a href="#hui-su-suan-fa" class="header-anchor">#</a></h2><h3><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h3><p>回溯算法是一个类似枚举的搜索尝试过程，主要在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。深度优先。</p>
<p>回溯算法是一种选优搜索法，按选优条件向前搜索，以达到目标。当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术成为回溯法，而满足回溯条件的某个状态的点成为“回溯点”。</p>
<p>对于回溯算法的简单描述是：把问题的解空间转化为图或树的结构，然后使用<strong>深度优先</strong>进行遍历，遍历过程中寻找所有可行解，从而找到最优解。</p>
<p>其基本思想类似于：图的深度优先搜索；二叉树的后序遍历。</p>
<p>回溯法的详细描述为：回溯法按深度优先搜索解空间树。首先从根节点出发，当搜索到解空间数的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。</p>
<h3><span id="shi-xian-fang-fa">实现方法</span><a href="#shi-xian-fang-fa" class="header-anchor">#</a></h3><p>递归与迭代</p>
<h3><span id="jing-dian-wen-ti">经典问题</span><a href="#jing-dian-wen-ti" class="header-anchor">#</a></h3><p>0-1背包问题</p>
<p>有n种物品和一个背包，第i种物品的重量是wi，其价值为pi，背包的容量为c. 问：怎样把物品装入背包，背包中的物品的总价值最大。</p>
<p>分析：从n种物品中选择部分物品，这样的题目解空间是子集树。例如，当物品的种类数为3是，其解空间如下图：</p>
<img src="/2020/05/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/tree.png" class title="tree">

<p>边1表示选择该物品，边0表示不选择该物品。这样，这个树从根节点到叶子节点，包含了把物品放入背包的所有可能性。<br>回溯搜索过程，如果来到了叶子节点，表示一条搜索路径结束，如果该路径上存在更优的解，则保存下来，如果不是叶子节点，是中间的节点（如B）, 就遍历其子节点（D和E), 如果子节点满足剪枝条件，就继续回溯搜索子节点。</p>
<h2><span id="fen-zhi-xian-jie-suan-fa">分支限界算法</span><a href="#fen-zhi-xian-jie-suan-fa" class="header-anchor">#</a></h2><h3><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h3><p>类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是满足约束条件的一个解，或是从满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p>
<p>分支限界法的基本思想是对有约束条件的最优化问题的所有可行解（数目有限）空间进行搜索。该算法在具体执行时，把全部可行的解空间不断分割为越来越小的自己（成为分支），并为每个自己内的解的值计算一个下界或上界（成为界定）。</p>
<p>在每次分支后，对凡是界限超出已知可行解值的那些子集不再做进一步分支。这样，解的许多子集（即搜索树上的许多节点）就可以不必考虑了，从而缩小了搜索范围。这一过程一直进行到找出可行解为止，该可行解的值不大于任务子集的界限，因此这种算法一般可以求得最优解。</p>
<p>将问题分支为子问题，并对这些子问题定界的步骤称为分支定界法。</p>
<h3><span id="jing-dian-wen-ti">经典问题</span><a href="#jing-dian-wen-ti" class="header-anchor">#</a></h3><p>旅行售货员问题</p>
<p>1）问题描述：某售货员要到若干城市去卖商品，已知各城市之间的路程。他要选定一条从驻地出发，经过每个城市一次，最后回到驻地的路线，使总的路程最小。</p>
<p>下图为1，2，3，4 四个城市及路线图，任意两个城市之间不一定都有路可达。</p>
<img src="/2020/05/26/%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/map.png" class title="map">

<p>2）问题理解：<br>分支限界法利用：广度优先搜索和最优值策略<br>利用二位数组保存图信息，一旦一个城市没有通向另外城市的路，则不可能有回路，不用再找下去了。<br>我们任意选择一个城市，作为出发点（因为最后都是一个回路，从哪出发都一样）</p>
<p>3）关键思路：<br>想象一下，我们就是旅行员，从城市1出发，根据广度优先搜索的思路，我们要把从城市1能到达的下一个城市，都要作为一种路径走一下试试。可在程序里面怎样实现这种“试试”呢？</p>
<p>答案是：可以利用一种数据结构，保存我们每走一步后，当前的一些状态参数。比如，我们已经走过的城市数目（这样就知道，我们有没有走完，比如上图，当我们走了四个城市之后，无论从第四个城市是否能回到起点城市，都意味着我们走完了，只是这条路径合不合约束以及能不能得到最优解的问题）。我们把这种保存状态参数的数据结构定义成Node。需要另一个数据结构用来保存我们每次试出来的路径，这就是MiniHeap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node&#123;</span><br><span class="line"><span class="keyword">int</span> s; <span class="comment">//结点深度，即当前走过了几个城市</span></span><br><span class="line"><span class="keyword">int</span> x[MAX_SIZE]; <span class="comment">//保存走到这个结点时的路径信息</span></span><br><span class="line">&#125;</span><br><span class="line">MiniHeap&#123;</span><br><span class="line"><span class="comment">//保存所有结点并提供一些结点的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/algorithm/" rel="tag"><i class="fa fa-tag"></i> algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/23/DFS%E4%B8%8EBFS/" rel="prev" title="DFS与BFS">
      <i class="fa fa-chevron-left"></i> DFS与BFS
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/13/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="next" title="python正则表达式">
      python正则表达式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">分治算法#</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">1.2.</span> <span class="nav-text">适用场景#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">1.3.</span> <span class="nav-text">经典场景#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">1.4.</span> <span class="nav-text">经典例题#</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">动态规划算法#</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.1.</span> <span class="nav-text">基本概念#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.</span> <span class="nav-text">适用场景#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.3.</span> <span class="nav-text">经典问题#</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">贪心算法#</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">3.1.</span> <span class="nav-text">基本概念#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">3.2.</span> <span class="nav-text">与DP对比#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">3.3.</span> <span class="nav-text">经典问题#</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">回溯算法#</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">4.1.</span> <span class="nav-text">基本概念#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">4.2.</span> <span class="nav-text">实现方法#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">4.3.</span> <span class="nav-text">经典问题#</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.</span> <span class="nav-text">分支限界算法#</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">5.1.</span> <span class="nav-text">基本概念#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">5.2.</span> <span class="nav-text">经典问题#</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="swaggyTech"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">swaggyTech</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swaggyTech</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'pFQbbI3wkDMVPFSxV5bMvwLK-gzGzoHsz',
      appKey: 'S9T17PSp3bwcaxF9q32Ns1b4',
      placeholder: "切磋一下",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
